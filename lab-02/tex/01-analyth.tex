\chapter{Аналитический раздел}\label{analyth}

В этом разделе будут представлены описания алгоритмов нахождения редакторских расстояний Левенштейна и Дамерау-Левенштейна и их практическое применение.


\section{Применение математического подхода}
Даны матрицы, $A \in \mathbb{R}^{m \times n}$, $B \in \mathbb{R}^{n \times p}$, произведение матриц, $B \in \mathbb{R}^{m \times p}$ --- такая матрица, $C = A \times B$, каждый элемент которой вычисляется согласно формуле \ref{math:mtx-arythm}:

\begin{equation}\label{math:mtx-arythm} 
	c_{i,j} = \sum_{n}^{k = 1}a_{i, k}\cdot b_{k, j}, \text{  где } i = \overline{1, m}, j = \overline{1, p} 
\end{equation}

\noindent Стандартный алгоритм умножения матриц реализует формулу(\ref{math:mtx-arythm}). 

Операция умножения двух матриц выполнима только в том случае, если число столбцов в первом сомножителе равно числу строк во втором. В частности, умножение всегда выполнимо, если оба сомножителя — квадратные матрицы одного и того же порядка. 

\section{Алгоритм Копперсмита – Винограда}
Для начала стоит обратить внимание на альтернативный подсчет выражения $a_1 \cdot b_1 + a_2 \cdot b_2$ осуществляется согласно \ref{math:inner-alter}:
\begin{equation}\label{math:inner-alter}
	\begin{array}{llll}
		\lambda_1 = a_1 \cdot a_1 \\
		\lambda_2 = b_1 \cdot b_1 \\
		\lambda_3 = (a_1 + b_2) \cdot (a_2 + b_1) \\
		\text{результат: } \lambda_3 - \lambda_1 - \lambda_2 \\ 
	\end{array}
\end{equation}

Классическое умножение матриц, по своей сути, является нахождением некоторого числа скалярных произведений каждого столбца первого множителя с каждой строкой второго. Процедура может быть усовершенствована: если один вектор $V$ встречается множество раз, то операция нахождения векторного произведения для него может быть выполнена единожды. Идея препроцессирования в случае перемножения квадратных матриц, $n \times n$ приводит к определению алгоритма Копперсмита – Винограда. Для вектора, $x = \left(x_1 \cdots x_n\right)$, можно записать(\ref{math:w-inner-product}):
\begin{equation}\label{math:w-inner-product}
	W(x) = x_1 \cdot x_2 + x_3 \cdot x_4 + \cdots + x_{n - 1} \cdot x_n
\end{equation}
Тогда умножения матрицы выполняется согласно следующему алгоритму:
\begin{enumerate}
	\item Для каждой строки $R_i$ матрицы $M$ вычислить $W(R_i)$ и для каждого столбца $C_i$ матрицы $M$ вычислить $W(C_i)$;
	\item Для каждой пары $(i ,j)$, где $r$ соответствует $R_i$ и $C$ соответствует $C_i$, вычислить \ref{math:winograde-iter}:
	\begin{equation}\label{math:winograde-iter} 
		\begin{array}{cc}
			r \cdot c = \left(r_1 + c_2\right) + \left(r_2 + c_1\right) \cdot \left(r_3 + c_4\right) \cdot \\
			\left(r_4 + c_3\right) + \cdots +  \left(r_{n - 1} + c_n\right) + \left(r_{n} + c_{n - 1}\right) - W\left(r\right) - W\left(c\right).
		\end{array}
	\end{equation}
\end{enumerate}

Если оценивать подход Копперсмита – Винограда опуская идею препроцессирования, то можно заметить, что арифметических операций в ней больше, чем в формуле классического скалярного произведения Однако, сохранение результатов $W(C_i)$ и $W(R_i)$ позволяет выполнять меньше операций, чем при нахождении матричного произведения математически. Разница при таком подходе, очевидно, будет заметна на матрицах настолько больших размеров, что они не могут быть обработаны ЭВМ. 

\section{Вывод}
Была выявлена основная особенность подхода Копперсмита – Винограда --- идея предварительной обработки. Разница во времени выполнения при такой оптимизации будет экспериментально вычислена в исследовательском разделе. 