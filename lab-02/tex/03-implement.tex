\chapter{Технологический раздел}

\section{Требования к ПО}

Программное обеспечение должно удовлетворять следующим требованиям:
\begin{itemize}
	\item Программа получает на вход с клавиатуры две матрицы размеров в пределах $10000 \times 10000$ либо получает два числа -- размерность матрицы в пределах $10000$;
	\item Программа выдает матрицу - произведение двух полученных матриц.
\end{itemize}

\section{Средства реализации} 
Для реализации ПО был выбран язык программирования Golang\cite{golang}. Данный язык предоставляет следующие возможности:
\begin{itemize} 
	\item Средства объектно-ориентированного программирования ограничиваются интерфейсами, что позволяет создавать абстракции, которые нужны для представления матрицы;
	\item Поддерживает библиотеки C и C++, что позволит измерить процессорное время, также имеет свою обширную библиотеку.
\end{itemize}

В качестве среды разработки была выбрана среда VS Code\cite{vscode}, запуск происходил через команду go run main.go.

\section{Листинги кода}
Листинг \ref{lst:algebr} демонстрирует классический алгоритм умножения. 
\\
\\
\\
\captionsetup{singlelinecheck = false, justification=raggedright}
\begin{lstlisting}[label=lst:algebr,caption=Классический алгоритм умножения]
func SimpleMult(amat, bmat MInt) MInt {
	rmat := formResMat(amat.n, bmat.m)
	for i := 0; i < rmat.n; i++ {
		for j := 0; j < rmat.m; j++ {
			for k := 0; k < amat.m; k++ {
				rmat.mat[i][j] += amat.mat[i][k] * bmat.mat[k][j]
			}
		}
	}
	return rmat
}
\end{lstlisting}
Листинг \ref{lst:winograd} -- умножение матриц алгоритмом Винограда.
\begin{lstlisting}[label=lst:winograd,caption=Алгоритм умнложения Виноградом]
func WinogradMult(amat, bmat MInt) MInt {
	rmat := formResMat(amat.n, bmat.m)
	rowcf := precomputeWinogradRows(amat)
	colcf := precomputeWinogradCols(bmat)
	
	for i := 0; i < rmat.n; i++ {
		for j := 0; j < rmat.m; j++ {
			for k := 0; k < rmat.m/2; k++ {
				rmat.mat[i][j] = rmat.mat[i][j] + 
				(amat.mat[i][k*2]+bmat.mat[k*2+1][j])*
				(amat.mat[i][k*2+1]+bmat.mat[k*2][j]) -
				rowcf.mat[i][k] - colcf.mat[k][j]
			}
		}
	}
	if rmat.m%2 != 0 {
		for i := 0; i < rmat.n; i++ {
			for j := 0; j < rmat.m; j++ {
				rmat.mat[i][j] += amat.mat[i][amat.m-1] * bmat.mat[bmat.n-1][j]
			}
		}
	}
	return rmat
}
\end{lstlisting}	


Листинг \ref{lst:winograd-optimized} -- умножение оптимизированным согласно \ref{sect:optimize} алгоритмом винограда.
\begin{lstlisting}[label=lst:winograd-optimized,caption=Оптимизированный алгоритм умнложения Виноградом]
func WinogradMultImp(amat, bmat MInt) MInt {
	
	rmat := formResMat(amat.n, bmat.m)
	
	rowcf := precomputeWinogradRowsImp(amat)
	colcf := precomputeWinogradColsImp(bmat)
	
	for i := 0; i < rmat.n; i++ {
		for j := 0; j < rmat.m; j++ {
			for k := 0; k < rmat.m-1; k += 2 {
				
				l := k/2 + k%2
				rmat.mat[i][j] += 
				(amat.mat[i][k]+bmat.mat[k+1][j])
				*(amat.mat[i][k+1]+bmat.mat[k][j]) -
				rowcf.mat[i][l] - colcf.mat[l][j]
				
			}
		}
	}
	
	if rmat.m%2 != 0 {
		k := amat.m - 1
		for i := 0; i < rmat.n; i++ {
			for j := 0; j < rmat.m; j++ {
				
				rmat.mat[i][j] += amat.mat[i][k] * bmat.mat[k][j]
				
			}
		}
	}
	
	return rmat
}
\end{lstlisting}
Функции оптимизации, реализующие формулу \ref{math:w-inner-product} представлены на листинге \ref{lst:winograd-precomp}
\begin{lstlisting}[label=lst:winograd-precomp,caption=Функции препроцессирования для алгоримов Винограда]
func precomputeWinogradRowsImp(mat MInt) MInt {
	s := mat.m / 2
	cf := formResMat(mat.n, s)
	
	for i := 0; i < mat.n; i++ {
		for j := 0; j < mat.m-1; j += 2 {
			cf.mat[i][j/s+j%2] = mat.mat[i][j] * mat.mat[i][j+1]
		}
	}
	
	return cf
}

func precomputeWinogradColsImp(mat MInt) MInt {
	s := mat.n / 2
	cf := formResMat(s, mat.m)
	
	for i := 0; i < mat.n-1; i += 2 {
		for j := 0; j < mat.m; j++ {
			cf.mat[i/s+i%2][j] = mat.mat[i][j] * mat.mat[i+1][j]
		}
	}
	
	return cf
}
\end{lstlisting}


\captionsetup{singlelinecheck = false, justification=raggedleft}
\section{Тестирование ПО}

В таблице \ref{table:testing} представлены следующие переменные:
\begin{itemize}
	\item AG --- Матрица полученная классическим алгоритмом перемножения матриц;
	\item CW --- Матрица полученная алгоритмом Винограда;
	\item CW OPT --- Матрица полученная оптимизированным алгоритмом Винограда .
\end{itemize}

\begin{table}[ht!]
	\renewcommand{\arraystretch}{1.8}
	\caption{Тестовые случаи}
	\resizebox{\textwidth}{!}{
		\begin{tabular}{||c|c|c|c|c|c||}
			\hline
			\multirow{2}{*}{№} & \multirow{2}{*}{Входная матрица №1} & \multirow{2}{*}{Входная матрица №2} & \multicolumn{3}{c|}{Результат} \\ \cline{4-6} 
			&  &  & AG & CW & CW OPT \\ \hline\hline
			1 & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ -3 & 5 & -1 & 7 \\\\ -8 & 2 & -2 & 1 \\\\ 0 & -3 & -4 & 0 \\\\ -6 & 0 & 5 & 1 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ -3 & 5 & -1 & 7 \\\\ -8 & 2 & -2 & 1 \\\\ 0 & -3 & -4 & 0 \\\\ -6 & 0 & 5 & 1 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ -73 & -2 & 32 & -9 \\\\ 2 & -30 & 17 & -53 \\\\ 24 & 6 & 22 & -3 \\\\ 12 & -45 & -9 & -41 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ -73 & -2 & 32 & -9 \\\\ 2 & -30 & 17 & -53 \\\\ 24 & 6 & 22 & -3 \\\\ 12 & -45 & -9 & -41 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ -73 & -2 & 32 & -9 \\\\ 2 & -30 & 17 & -53 \\\\ 24 & 6 & 22 & -3 \\\\ 12 & -45 & -9 & -41 \\\\ \end{matrix}$\end{tabular} \\ 
			2 & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 0 & 0 & -2 \\\\ 2 & 3 & 2 \\\\ -4 & 0 & -1 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 0 & 0 & -2 \\\\ 2 & 3 & 2 \\\\ -4 & 0 & -1 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 8 & 0 & 2 \\\\ -2 & 9 & 0 \\\\ 4 & 0 & 9 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 8 & 0 & 2 \\\\ -2 & 9 & 0 \\\\ 4 & 0 & 9 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 8 & 0 & 2 \\\\ -2 & 9 & 0 \\\\ 4 & 0 & 9 \\\\ \end{matrix}$\end{tabular} \\ 
			3 & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 5 & 7 \\\\ 7 & 0 \\\\ 3 & 1 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 5 & 7 & 7 & 0 \\\\ 3 & 1 & -7 & 5 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 46 & 42 & -14 & 35 \\\\ 35 & 49 & 49 & 0 \\\\ 18 & 22 & 14 & 5 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 46 & 42 & -14 & 35 \\\\ 35 & 49 & 49 & 0 \\\\ 18 & 22 & 14 & 5 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 46 & 42 & -14 & 35 \\\\ 35 & 49 & 49 & 0 \\\\ 18 & 22 & 14 & 5 \\\\ \end{matrix}$\end{tabular} \\ 
			4 & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ -4 & 9 \\\\ -4 & -1 \\\\ -1 & 5 \\\\ 5 & 3 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ -4 & 9 & -4 \\\\ -1 & -1 & 5 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 7 & -45 & 61 \\\\ 17 & -35 & 11 \\\\ -1 & -14 & 29 \\\\ -23 & 42 & -5 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 7 & -45 & 61 \\\\ 17 & -35 & 11 \\\\ -1 & -14 & 29 \\\\ -23 & 42 & -5 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 7 & -45 & 61 \\\\ 17 & -35 & 11 \\\\ -1 & -14 & 29 \\\\ -23 & 42 & -5 \\\\ \end{matrix}$\end{tabular} \\ \hline
		\end{tabular}
	}
	\label{table:testing}
\end{table}
\section{Вывод}
Было написано и протестировано программное обеспечение для решения поставленной задачи.