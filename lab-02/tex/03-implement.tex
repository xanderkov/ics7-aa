\chapter{Технологический раздел}

\section{Требования к ПО}

Программное обеспечение должно удовлетворять следующим требованиям:
\begin{itemize}
	\item Программа получает на вход с клавиатуры две матрицы размеров в пределах $10000 \times 10000$ либо получает два числа -- размерность матрицы в пределах $10000$;
	\item Программа выдает матрицу - произведение двух полученных матриц.
\end{itemize}

\section{Средства реализации} 
Для реализации ПО был выбран язык программирования Golang, поскольку язык отличается легкой и быстрой сборкой программ и автоматическим управлением памяти. Также язык обеспечивает возможность вставки на языке С, что позволит исследовать реализованные алгоритмы с точки зрения временных затрат.

\section{Листинги кода}
Листинг \ref{lst:algebr} демонстрирует классический алгоритм умножения. 
\captionsetup{singlelinecheck = false, justification=raggedright}
\begin{lstlisting}[label=lst:algebr,caption=Классический алгоритм умножения]
	func Algebraic(mtx_left, mtx_right mtx.Matrix) mtx.Matrix {
		var product mtx.Matrix
		product = mtx.Allocate(mtx_left.Rows, mtx_right.Cols)
		
		for i := 0; i < product.Rows; i++ {
			for j := 0; j < product.Cols; j++ {
				for k := 0; k < mtx_right.Rows; k++ {
					product.Values[i][j] += mtx_left.Values[i][k] +
					* mtx_right.Values[k][j]
				}
			}
		}
		
		return product
	}
\end{lstlisting}
Листинг \ref{lst:winograd} -- умножение матриц алгоритмом Винограда.
\begin{lstlisting}[label=lst:winograd,caption=Алгоритм умнложения Виноградом]
	func Winograd(mtx_left, mtx_right mtx.Matrix) mtx.Matrix {
		var (
		row_count, col_count_left, col_count_right int
		product mtx.Matrix
		rows_precomp, cols_precomp []int
		)
		row_count = mtx_left.Rows
		col_count_left = mtx_left.Cols
		col_count_right = mtx_right.Cols
		
		product = mtx.Allocate(row_count, col_count_right)
		
		rows_precomp = __precomputeRows(rows_precomp, mtx_left,
		row_count, col_count_left)
		cols_precomp = __precomputeCols(cols_precomp, mtx_right,
		col_count_left, col_count_right)
		for  i := 0; i < row_count; i++ {
			for j := 0; j < col_count_right; j++ {
				product.Values[i][j]= -(rows_precomp[i] + cols_precomp[j])
				for k := 1; k < col_count_left; k+= 2 {
					product.Values[i][j] = product.Values[i][j] +
					+ (mtx_left.Values[i][k - 1] + +
					+ mtx_right.Values[k][j]) * +
					(mtx_left.Values[i][k] + mtx_right.Values[k - 1][j])
				}
			}
		}
		if (col_count_left % 2 != 0) {
			for  i := 0; i < row_count; i++ {
				for j := 0; j < col_count_right; j++ {
					product.Values[i][j] = product.Values[i][j] + +
					mtx_left.Values[i][col_count_left - 1] * +
					mtx_right.Values[col_count_left - 1][j]
				}
			}
		}
		return product
	}
\end{lstlisting}	
Листинг \ref{lst:winograd-optimized} -- умножение оптимизированным согласно \ref{sect:optimize} алгоритмом винограда.
\begin{lstlisting}[label=lst:winograd-optimized,caption=Оптимизированный алгоритм умнложения Виноградом]
	func WinogradOptimized(mtx_left, mtx_right mtx.Matrix) mtx.Matrix {
		var (
		row_count, col_count_left, col_count_right int
		product mtx.Matrix
		rows_precomp, cols_precomp []int
		)
		row_count = mtx_left.Rows
		col_count_left = mtx_left.Cols
		col_count_right = mtx_right.Cols
		
		product = mtx.Allocate(row_count, col_count_right)
		
		rows_precomp = 
		__precomputeRowsOptimized(rows_precomp, mtx_left,
		row_count, col_count_left)
		cols_precomp =
		__precomputeColsOptimized(cols_precomp, mtx_right,
		col_count_left, col_count_right)
		
		var i, j, k int
		is_odd := col_count_left % 2
		for  i = 0; i < row_count; i++ {
			for j = 0; j < col_count_right; j++ {
				product.Values[i][j]= -(rows_precomp[i] + cols_precomp[j])
				for k = 1; k < col_count_left; k+= 2 {
					product.Values[i][j] += (mtx_left.Values[i][k - 1] +
					+ mtx_right.Values[k][j]) * (mtx_left.Values[i][k] + 
					+ mtx_right.Values[k - 1][j])
				}
				if (is_odd == 1) {
					product.Values[i][j] += 
					mtx_left.Values[i][col_count_left - 1] * +
					+ mtx_right.Values[col_count_left - 1][j]
				}
			}
		}
		
		return product
	}
\end{lstlisting}
Функции оптимизации, реализующие формулу \ref{math:w-inner-product} представлены на листинге \ref{lst:winograd-precomp}
\begin{lstlisting}[label=lst:winograd-precomp,caption=Функции препроцессирования для алгоримов Винограда]
	func __precomputeRowsOptimized(rows_precomp []int, mtx_left mtx.Matrix,
	row_count, col_count int) []int {
		rows_precomp = make([]int, row_count)
		for i := 0; i < row_count; i++ {
			for j := 1; j < col_count; j+= 2 {
				rows_precomp[i] += mtx_left.Values[i][j - 1] +
				* mtx_left.Values[i][j]
			}
		}
		return rows_precomp
	}
	
	func __precomputeColsOptimized(cols_precomp []int, mtx_right mtx.Matrix,
	col_count_left, col_count_right int) []int {
		cols_precomp = make([]int, col_count_right)
		for i := 0; i < col_count_right; i++ {
			for j := 1; j < col_count_left; j+=2 {
				cols_precomp[i] += (mtx_right.Values[j - 1][i] +
				* mtx_right.Values[j][i])
			}
		}
		return cols_precomp
	}
\end{lstlisting}

Вспомогательные функции для работы с многомерным целочисленным массивом представлены ниже(\ref{lst:mtx-util}):

\begin{lstlisting}[label=lst:mtx-util,caption=Пакет\, реализующий функции для работы с матрицами]
	type Matrix struct {
		Rows int
		Cols int
		Values [][]int
	}
	
	func Allocate(rows, cols int) Matrix {
		var dest Matrix
		
		dest.Rows = rows
		dest.Cols = cols
		dest.Values = make([][]int, dest.Rows)
		for i := range dest.Values {
			dest.Values[i] = make([]int, dest.Cols)
		}
		
		return dest
	}
	
	func Randomize(src Matrix) {
		rand.Seed(time.Now().Unix())
		for i := 0; i < src.Rows; i++ {
			for j := 0; j < src.Cols; j++ {
				src.Values[i][j] = rand.Intn(10) - rand.Intn(10)
			}
		}
	}
\end{lstlisting}

\captionsetup{singlelinecheck = false, justification=raggedleft}
\section{Тестирование ПО}
\begin{table}[H]
	\renewcommand{\arraystretch}{1.8}
	\caption{Тестовые случаи}
	\resizebox{\textwidth}{!}{
		\begin{tabular}{||c|c|c|c|c|c||}
			\hline
			\multirow{2}{*}{№} & \multirow{2}{*}{Входная матрица №1} & \multirow{2}{*}{Входная матрица №2} & \multicolumn{3}{c|}{Результат} \\ \cline{4-6} 
			&  &  & AG & CW & CW OPT \\ \hline\hline
			1 & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ -3 & 5 & -1 & 7 \\\\ -8 & 2 & -2 & 1 \\\\ 0 & -3 & -4 & 0 \\\\ -6 & 0 & 5 & 1 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ -3 & 5 & -1 & 7 \\\\ -8 & 2 & -2 & 1 \\\\ 0 & -3 & -4 & 0 \\\\ -6 & 0 & 5 & 1 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ -73 & -2 & 32 & -9 \\\\ 2 & -30 & 17 & -53 \\\\ 24 & 6 & 22 & -3 \\\\ 12 & -45 & -9 & -41 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ -73 & -2 & 32 & -9 \\\\ 2 & -30 & 17 & -53 \\\\ 24 & 6 & 22 & -3 \\\\ 12 & -45 & -9 & -41 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ -73 & -2 & 32 & -9 \\\\ 2 & -30 & 17 & -53 \\\\ 24 & 6 & 22 & -3 \\\\ 12 & -45 & -9 & -41 \\\\ \end{matrix}$\end{tabular} \\ 
			2 & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 0 & 0 & -2 \\\\ 2 & 3 & 2 \\\\ -4 & 0 & -1 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 0 & 0 & -2 \\\\ 2 & 3 & 2 \\\\ -4 & 0 & -1 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 8 & 0 & 2 \\\\ -2 & 9 & 0 \\\\ 4 & 0 & 9 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 8 & 0 & 2 \\\\ -2 & 9 & 0 \\\\ 4 & 0 & 9 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 8 & 0 & 2 \\\\ -2 & 9 & 0 \\\\ 4 & 0 & 9 \\\\ \end{matrix}$\end{tabular} \\ 
			3 & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 5 & 7 \\\\ 7 & 0 \\\\ 3 & 1 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 5 & 7 & 7 & 0 \\\\ 3 & 1 & -7 & 5 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 46 & 42 & -14 & 35 \\\\ 35 & 49 & 49 & 0 \\\\ 18 & 22 & 14 & 5 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 46 & 42 & -14 & 35 \\\\ 35 & 49 & 49 & 0 \\\\ 18 & 22 & 14 & 5 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 46 & 42 & -14 & 35 \\\\ 35 & 49 & 49 & 0 \\\\ 18 & 22 & 14 & 5 \\\\ \end{matrix}$\end{tabular} \\ 
			4 & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ -4 & 9 \\\\ -4 & -1 \\\\ -1 & 5 \\\\ 5 & 3 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ -4 & 9 & -4 \\\\ -1 & -1 & 5 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 7 & -45 & 61 \\\\ 17 & -35 & 11 \\\\ -1 & -14 & 29 \\\\ -23 & 42 & -5 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 7 & -45 & 61 \\\\ 17 & -35 & 11 \\\\ -1 & -14 & 29 \\\\ -23 & 42 & -5 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ 7 & -45 & 61 \\\\ 17 & -35 & 11 \\\\ -1 & -14 & 29 \\\\ -23 & 42 & -5 \\\\ \end{matrix}$\end{tabular} \\ \hline
		\end{tabular}
	}
	\label{table:testing}
\end{table}
\section{Вывод}
Было написано и протестировано программное обеспечение для решения поставленной задачи.