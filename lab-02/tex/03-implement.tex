\chapter{Технологический раздел}

В данном разделе будут приведены требования к программному обеспечению, средства реализации и листинга кода.

\section{Требования к ПО}

Программное обеспечение должно удовлетворять следующим требованиям:
\begin{itemize}
	\item программа получает на вход с клавиатуры две матрицы размеров в пределах $10000 \times 10000$ либо получает два числа -- размерность матрицы в пределах $10000$;
	\item программа выдает матрицу - произведение двух полученных матриц;
	\item в программе возможно измерение процессорного времени.
\end{itemize}

\section{Средства реализации} 
Для реализации ПО был выбран язык программирования Python\cite{python}. 

В данном языке есть все требующиеся инструменты для данной лабораторной работы.

В качестве среды разработки была выбрана среда VS Code\cite{vscode}, запуск происходил через команду python main.py.

\section{Средства замера времени}

Алгоритмы тестировались при помощи функции process\_time библиотеки time \ref{bench}. Данная команда возвращает значения процессорного времени типа int в наносекундах.

Замеры времени для каждого алгоритма проводились 100 раз.

\begin{lstlisting}[label=bench,caption=Пример теста эффективности]
	def test_simple_mult(A, B):
	# Start the stopwatch / counter 
	t1_start = process_time() 
	for i in range(N_TEST):
	simple_mult(A, M, B, N, M)
	# Stop the stopwatch / counter
	t1_stop = process_time()
\end{lstlisting}



\section{Реализации алгоритмов}
Листинг \ref{lst:algebr} демонстрирует классический алгоритм умножения. 


\captionsetup{singlelinecheck = false, justification=raggedright}
\begin{lstlisting}[label=lst:algebr,caption=Классический алгоритм умножения]
def simple_mult(mat1, m, mat2, n, q):
	res = np.zeros([m, q])
	for i in range(m):
		for j in range(q):
			for k in range(n):
				res[i][j] = res[i][j] + mat1[i][k] * mat2[k][j]
	return res
\end{lstlisting}

\newpage
Листинг \ref{lst:winograd} -- умножение матриц алгоритмом Винограда.

\begin{lstlisting}[label=lst:winograd,caption=Алгоритм умнложения Виноградом]
def precompile\_rows\_win(mat, n, m):
	mh = np.zeros([n])
	for i in range(n):
		for j in range(m // 2):
			mh[i] = mh[i] + mat[i][j * 2] * mat[i][j * 2 + 1]
	return mh

def precompile\_cols\_win(mat, n, m):
	mv = np.zeros([m])
	
	for i in range(m):
		for j in range(n // 2):
			mv[i] = mv[i] + mat[j * 2][i] * mat[j * 2 + 1][i]
	return mv

def winograd\_mult(A, m, B, n, q):
	res = np.zeros([m, q])
	mh = precompile\_rows\_win(A, m, n)
	mv = precompile\_cols\_win(B, n, q)
	for i in range(m):
		for j in range(q):
		res[i][j] = -mh[i] - mv[j]
		for k in range(n // 2):
			res[i][j] = res[i][j] + (A[i][k*2] + B[k*2+1][j])*(A[i][k*2+1] + B[k*2][j])
	if n \% 2 != 0:
		for i in range(n):
			for j in range(m):
				res[i][j] = res[i][j] + A[i][n-1]*B[n-1][j]
	return res

\end{lstlisting}	

\newpage
Листинг \ref{lst:winograd-optimized} -- умножение оптимизированным алгоритмом Винограда.
\begin{lstlisting}[label=lst:winograd-optimized,caption=Оптимизированный алгоритм умножения Виноградом]
def precompile_rows_win_opt(mat, n, m):
	mh = np.zeros([n])
	opt = m // 2
	for i in range(n):
		for j in range(opt):
			t = j << 1
			mh[i] += mat[i][t] * mat[i][t + 1]
	return mh

def precompile_cols_win(mat, n, m):
	mv = np.zeros([m])
	
	opt = n // 2
	for i in range(m):
		for j in range(opt):
			t = j << 1
			mv[i] += mat[t][i] * mat[t + 1][i]
	return mv

def winograd_mult_opt(A, m, B, n, q):
	res = np.zeros([m, q])
	mh = precompile_rows_win(A, m, n)
	mv = precompile_cols_win(B, n, q)
	
	opt = n // 2
	for i in range(m):
		for j in range(q):
			res[i][j] = -mh[i] - mv[j]
			for k in range(n // 2):
				t = k << 1
				res[i][j] += (A[i][t] + B[t+1][j])*(A[i][t+1] + B[t][j])
	if n % 2 != 0:
		for i in range(n):
			for j in range(m):
				res[i][j] += A[i][n-1]*B[n-1][j]
	return res
\end{lstlisting}


\captionsetup{singlelinecheck = false, justification=raggedleft}



\section{Тестовые данные}


\begin{table}[ht!]
	\renewcommand{\arraystretch}{1.8}
	\caption{Тестовые случаи}
	\resizebox{\textwidth}{!}{
		\begin{tabular}{||c|c|c|c|c|c||}
			\hline
			\multirow{2}{*}{№} & \multirow{2}{*}{Вход. матрица №1} & \multirow{2}{*}{Вход. матрица №2} & \multicolumn{3}{c|}{Результат} \\ \cline{4-6} 
			&  &  & Классический & Виноград & Виноград оптимизированный \\ \hline\hline
			1 & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ -3 & 5 & -1 & 7 \\\\ -8 & 2 & -2 & 1 \\\\ 0 & -3 & -4 & 0 \\\\ -6 & 0 & 5 & 1 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ -3 & 5 & -1 & 7 \\\\ -8 & 2 & -2 & 1 \\\\ 0 & -3 & -4 & 0 \\\\ -6 & 0 & 5 & 1 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ -73 & -2 & 32 & -9 \\\\ 2 & -30 & 17 & -53 \\\\ 24 & 6 & 22 & -3 \\\\ 12 & -45 & -9 & -41 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ -73 & -2 & 32 & -9 \\\\ 2 & -30 & 17 & -53 \\\\ 24 & 6 & 22 & -3 \\\\ 12 & -45 & -9 & -41 \\\\ \end{matrix}$\end{tabular} & \begin{tabular}[c]{@{}l@{}}$\begin{matrix}[0.6] \\ -73 & -2 & 32 & -9 \\\\ 2 & -30 & 17 & -53 \\\\ 24 & 6 & 22 & -3 \\\\ 12 & -45 & -9 & -41 \\\\ \end{matrix}$\end{tabular} \\ \hline
		\end{tabular}
	}
	\label{table:testing}
\end{table}

\newpage
\section*{Вывод}
Было написано и протестировано программное обеспечение для решения поставленной задачи.